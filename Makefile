.PHONY: build clean run-server run-worker run-client run-client-json run-client-concurrent run-client-file all

# Binary names and paths
BINARY_DIR = bin
SERVER_BINARY = $(BINARY_DIR)/server
WORKER_BINARY = $(BINARY_DIR)/worker
CLIENT_BINARY = $(BINARY_DIR)/client
WEBUI_BINARY = $(BINARY_DIR)/webui

# Build flags
GO = go
GOFLAGS = -v

# Build all binaries
build: $(BINARY_DIR) $(SERVER_BINARY) $(WORKER_BINARY) $(CLIENT_BINARY) $(WEBUI_BINARY)

# Create bin directory
$(BINARY_DIR):
	mkdir -p $(BINARY_DIR)

# Build server
$(SERVER_BINARY):
	$(GO) build $(GOFLAGS) -o $(SERVER_BINARY) ./cmd/server

# Build worker
$(WORKER_BINARY):
	$(GO) build $(GOFLAGS) -o $(WORKER_BINARY) ./cmd/worker

# Build client
$(CLIENT_BINARY):
	$(GO) build $(GOFLAGS) -o $(CLIENT_BINARY) ./cmd/client

$(WEBUI_BINARY):
	$(GO) build $(GOFLAGS) -o $(WEBUI_BINARY) ./cmd/webui

# Run server
run-server: $(SERVER_BINARY)
	set -a; [ -f .env ] && . ./.env; set +a; ./$(SERVER_BINARY)

# Run worker
run-worker: $(WORKER_BINARY)
	set -a; [ -f .env ] && . ./.env; set +a; ./$(WORKER_BINARY)

# Run client (with optional JSON file and concurrent flag)
run-client: $(CLIENT_BINARY)
	set -a; [ -f .env ] && . ./.env; set +a; ./$(CLIENT_BINARY)  

# Run client with default jobs.json file
run-client-json: $(CLIENT_BINARY)
	set -a; [ -f .env ] && . ./.env; set +a; ./$(CLIENT_BINARY) -file=jobs.json

# Run client with jobs concurrently
run-client-concurrent: $(CLIENT_BINARY)
	set -a; [ -f .env ] && . ./.env; set +a; ./$(CLIENT_BINARY) -file=jobs.json -concurrent

# Run client with custom JSON file
run-client-file: $(CLIENT_BINARY)
	@if [ -z "$(FILE)" ]; then echo "Usage: make run-client-file FILE=your-jobs.json"; exit 1; fi
	set -a; [ -f .env ] && . ./.env; set +a; ./$(CLIENT_BINARY) -file=$(FILE)

# Run multiple servers easily with optional etcd leader election
.PHONY: run-servers stop-servers run-client-servers

run-servers: $(SERVER_BINARY)
	set -a; [ -f .env ] && . ./.env; set +a; \
	COUNT=$${SERVER_COUNT:-3}; BASE=$${BASE_PORT:-50051}; \
	mkdir -p log/server; SERVERS=""; \
	for i in $$(seq 0 $$((COUNT-1))); do \
	  P=$$((BASE+i)); \
	  echo "Starting server on :$$P"; \
	  ETCD_ENV=""; \
	  if [ "$$ETCD_ENDPOINTS" != "" ]; then \
	    ETCD_ENV="ETCD_ENDPOINTS=$$ETCD_ENDPOINTS ELECTION_NAMESPACE=$${ELECTION_NAMESPACE:-/scheduler/v1} ELECTION_KEY=$${ELECTION_KEY:-leader} LEASE_TTL=$${LEASE_TTL:-10s}"; \
	  fi; \
	  sh -c "$$ETCD_ENV SERVER_PORT=$$P ./$(SERVER_BINARY)" > log/server/server_$$P.log 2>&1 & \
	  SERVERS="$${SERVERS:+$${SERVERS},}localhost:$$P"; \
	  sleep 0.2; \
	done; \
	echo $$SERVERS > .servers; echo "SERVERS=$$SERVERS"

stop-servers:
	pkill -f ./$(SERVER_BINARY) || true

# Run client using SERVERS from env or from .servers generated by run-servers
run-client-servers: $(CLIENT_BINARY)
	set -a; [ -f .env ] && . ./.env; set +a; \
	SERVERS_ENV="$$SERVERS"; \
	if [ -z "$$SERVERS_ENV" ] && [ -f .servers ]; then SERVERS_ENV=$$(cat .servers); fi; \
	if [ -z "$$SERVERS_ENV" ]; then echo "SERVERS not set and .servers not found. Run: make run-servers or set SERVERS=host1:port1,host2:port2"; exit 1; fi; \
	SERVERS="$$SERVERS_ENV" ./$(CLIENT_BINARY) -file=$${FILE:-jobs.json}

.PHONY: run-webui
run-webui: $(WEBUI_BINARY)
	WEBUI_ADDR=$${WEBUI_ADDR:-:8080} ./$(WEBUI_BINARY)

# Start all services (Postgres/Redis/etcd if available), servers, workers, and web UI
.PHONY: start stop
start: build
	set -a; [ -f .env ] && . ./.env; set +a; \
	mkdir -p log/{server,worker}; \
	if command -v brew >/dev/null 2>&1; then \
	  echo "Starting services via brew if installed..."; \
	  brew list postgresql@16 >/dev/null 2>&1 && brew services start postgresql@16 >/dev/null 2>&1 || true; \
	  brew list redis >/dev/null 2>&1 && brew services start redis >/dev/null 2>&1 || true; \
	  brew list etcd >/dev/null 2>&1 && brew services start etcd >/dev/null 2>&1 || true; \
	fi; \
	if command -v redis-cli >/dev/null 2>&1 && ! redis-cli ping >/dev/null 2>&1; then \
	  echo "Starting redis-server (daemonize)"; \
	  redis-server --daemonize yes >/dev/null 2>&1 || true; \
	fi; \
	$(MAKE) run-servers SERVER_COUNT=$${SERVER_COUNT:-3} BASE_PORT=$${BASE_PORT:-50051}; \
	WC=$${WORKER_COUNT:-1}; \
	for i in $$(seq 1 $$WC); do \
	  echo "Starting worker $$i"; \
	  $(MAKE) run-worker > log/worker/worker_$$i.log 2>&1 & \
	done; \
	if [ "$${START_WEBUI:-1}" != "0" ]; then \
	  echo "Starting web UI on $${WEBUI_ADDR:-:8080}"; \
	  WEBUI_ADDR=$${WEBUI_ADDR:-:8080} $(MAKE) run-webui > log/server/webui.log 2>&1 & \
	fi; \
	echo "All services started. Servers: $$(cat .servers 2>/dev/null || echo localhost:$${BASE_PORT:-50051})"

# Stop all app processes (servers, workers, webui). Does not stop system services
stop:
	$(MAKE) stop-servers || true
	pkill -f ./$(WORKER_BINARY) || true
	pkill -f ./$(WEBUI_BINARY) || true
	echo "Stopped servers, workers, and web UI."

# Clean build artifacts
clean:
	rm -rf $(BINARY_DIR) log

# Default target
all: clean build

# Helper target to show usage
help:
	@echo "Available targets:"
	@echo "  make build               - Build all binaries"
	@echo "  make run-server          - Run the server"
	@echo "  make run-worker          - Run the worker"
	@echo "  make run-client          - Run the client with options (FILE='file.json' CONCURRENT=true)"
	@echo "  make run-client-json     - Run the client with default jobs.json"
	@echo "  make run-client-concurrent - Run jobs concurrently from jobs.json"
	@echo "  make run-client-file     - Run with custom file (make run-client-file FILE=your-jobs.json)"
	@echo "  make clean               - Remove build artifacts"
	@echo "  make all                 - Clean and build all"
	@echo "  make help                - Show this help"
	@echo ""
	@echo "Example usage:"
	@echo "  make run-client-json                    # Use default jobs.json"
	@echo "  make run-client FILE=my-jobs.json       # Use custom JSON file"
	@echo "  make run-client CONCURRENT=true         # Run jobs concurrently"
	@echo "  make run-client-file FILE=custom.json   # Use specific file" 